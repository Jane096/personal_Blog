# 생성자 대신 정적 팩토리 메서드를 고려해보자 (feat. 이펙티브 자바)

<br>

## 정적 팩토리 메서드

프로그래머라면 누구나 알고있을 내용이지만, 클래스의 인스턴스를 얻는 방법 중 가장 잘 알려진 내용은 public 생성자를 통해 얻는 방법이다.
하지만! 생성자와 별도로 **정적 팩토리 메서드(static factory method)** 를 제공할 수 있다. 클래스의 인스턴스를 반환하는 단순한 정적 메서드를 말한다.

> 그런데, 정적 메서드는 어떻게 생겼을까?

<br>

### example

`boolean` 의 박싱클래스(boxed class) 인 `Boolean` 을 예시로 들어보았다. 아래의 코드가 바로 **정적 메서드** 이다.

<br>

```java
public static Boolean valueOf(boolean b) {
  return b ? Boolean.TRUE : Boolean.FALSE;
}
```

 <br>
 
 이처럼, 클래스는 클라이언트에게 public 생성자 대신 정적 팩토리 메서드를 제공해줄 수 있다. 물론 이를 이용함으로써 장점도 많이 존재하지만 단점도 존재한다. 
 먼저 장점부터 소개해보도록 하겠다.
 
 <br>
 <br>
 
 ## pros 1: 이름을 가질 수 있다.
 
 생성자에 넘기는 매개변수와 생성자 자체만으로는 반환될 객체의 특성을 제대로 설명하기가 힘들다. 하지만 정적 팩토리 메서드를 사용하여 이름만 명확하게 잘 짓는다면, 
 반환될 객체의 특성을 쉽게 설명할 수 있다. 예를들어, `BigInteger(int, int, Random)` 과 정적 팩토리 메서드인 `BigInteger.probablePrime` 이 둘 중에서 
 `값이 소수인 BigInteger를 반환한다` 라는 의미가 어느 쪽이 잘 맞아 떨어질까? 당연히 후자이다. 
 
 생성자는 단 1개만 생성이 가능하다는 특성을 지니고 있다. 물론, 입력 매개변수를 다르게 하여 생성자를 추가할 수는 있지만, 각 생성자가 어떤 역할을 하는 건지
 개발자 입장에선 혼동이 되기 때문에 썩 좋은 방법은 아니다. 하지만, 이름을 가질 수 있는 정적 팩토리 메서드를 사용할 때 이런 제약에서 자유롭다.
 
 즉, 한 클래스에서 이름이 같은 생성자가 여러 개 필요한 상황이 온다면 차라리 생성자를 정적 팩토리 메서드로 바꾸고 각각의 차이가 잘 드러나도록 명확하게 이름을 지어주는게
 더 나은 방법이 될 수 있다. 
 
 <br>
 <br>
 
 ## pros 2: 호출될 때 마다 인스턴스를 새로 생성하지 않아도 된다.
 
 정적 팩토리 메서드는 인스턴스를 미리 만들어 놓아 재활용이 가능하기 때문에 불필요한 객체생성을 피할 수 있다는 큰 장점이 있다. 위에서도 사용했던 예시인 
 `Boolean.valueOf(boolean)` 메서드 또한 객체를 아예 생성하지 않는다. 만약 같은 객체가 자주 요청이 되는 상황에서 큰 성능 향상을 느낄 수 있을 것이다. 
 
 반복되는 요청에 같은 객체를 반환하는 식으로 정적 팩토리 방식의 클래스는 **언제, 어느 인스턴스를 살아있게 할지** 를 제어할 수 있다. 그래서 이런 경우를
 **인스턴스 통제(instance-controlled)** 라고 부르기도 한다고 한다. 
 
 > 인스턴스를 왜 통제 하는지 궁금할 수도 있을 것 같다. 인스턴스를 통제 가능함으로써 싱글톤(Singleton) 으로 만들 수도 있고, 인스턴스화를 불가능하게 
 > 만들 수도 있다. 또한 불변 값 클래스에서 인스턴스가 단 하나만 생성됨을 보장할 수가 있다. 
 
 <br>
 <br>
 
 ## pros 3: 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다. 
 
 이 특징은 반환할 객체의 클래스를 자유롭게 선택할 수 있게 하는 높은 **유연성** 을 제공한다. API를 만들 때 이러한 유연성을 잘 응용한다면 구현 클래스를 굳이
 공개하지 않고도 그 객체를 반환할 수 있기 때문에 API를 작게 유지할 수 있다. 인터페이스를 정적 팩토리 메서드의 반환 타입으로 사용하는 인터페이스 기반 
 프레임워크를 만드는 핵심 기술이기도 하다. 
 
 자바8 이전에는 인터페이스를 정적 메서드로 선언을 할 수가 없었기 때문에 이름이 `Type` 인 인터페이스를 반환하는 정적 메서드가 필요한 경우에 `Types` 라는 
 인스턴스화가 불가능한 동반 클래스(Companion class)를 만들어 그 안에 정의를 했었다고 한다. 
 
 인터페이스를 정적 팩토리 메서드의 반환 타입을 사용하는 대표적인 예시가 바로 **컬렉션 프레임워크** 이다. 자바 컬렉션 프레임워크는 핵심 인터페이스들에
 수정 불가, 동기화 등의 기능을 덧붙인 총 45개의 유틸리디 구현체를 제공하는데, 이 구현체의 대부분은 단 하나의 인스턴스화 불가 클래스는 `java.util.Collections` 에서
 정적 펙토리 메서드를 통해 얻도록 했다. 
 
 이 컬렉션 프레임워크는 45개 클레스를 공개하지 않기 때문에 API 외견을 훨씬 작게 할 수 있었고, 프로그래머 또한 실제 구현 클래스가 무엇인지 알아보지 않아도 되기 때문에
 쉽게 익힐 수 있었다. 
 
 <br>
 <br>
 
 ## pros 4: 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
 
 반환 타입의 하위 타입이기만 한다면 어떤 클래스의 객체를 반환해도 상관없다. 예를 들어, `EnumSet` 클래스는 public 생성자 없이 오직 정적 팩토리만을
 제공하는 클래스 인데, OpenJDK 버전에서는 원소의 수에 따라 두 가지 하위 클래스 중 하나의 인스턴스를 반환한다. 
 
 > 원소가 64개 이하면 원소들을 `long` 변수 하나로 관리하는 `RegularEnumSet` 의 인스턴스를, 65개 이상이라면 `long` 배열로 관리하는 `JumboEnumSet` 의 인스턴스를
 > 반환한다.
 
 <br>
 
 물론, 클라이언트는 이 두 클래스의 존재를 모르고, 알 필요도 없다. 만약 원소가 적을 때는 `RegularEnumSet` 을 다음 릴리스에 삭제를 해도 되고, 성능을 개선한
 다음 두번째, 세번째 릴리스에 추가를 해도 된다. 그저 `EnumSet` 의 하위 클래스 이기만 하다면 클라이언트는 팩토리가 건네주는 객체가 어떤 건지 전혀 몰라도 무방하다.
 
 <br>
 <br>
 
 이렇게 장점을 알아보았다. 하지만 분명 단점도 존재하는데 어떤 단점이 존재할까?
 
 <br>
 
 ## cons 1: 상속을 하려면 public 이나 protected 생성자가 필요하니 정적 팩토리만 제공하면 하위클래스를 만들 수가 없다.
 
 위에서 언급했던 컬렉션 프레임워크의 유틸리티 구현 클래스들은 상속이 **불가능** 하다는 의미다. 하지만 이 제약은 상속보다 컴포지션을 사용하도록 유도하고
 불변 타입으로 만들려면 이 제약은 지켜야 하기 때문에 오히려 장점으로도 받아들여질 수 있는 부분이기도 하다.
 
 <br>
 <br>
 
 ## cons 2: 정적 팩토리 메서드는 프로그래머가 찾기 어렵다.
 
 생성자 처럼 API설명에 명확하게 드러나지는 않기 때문에 정적 팩토리 메서드 방식 클래스를 인스턴스화할 방법을 알아서 찾아내야 한다는 단점이 있다. 
 자바독이 이 귀찮은 일을 해주면 너무나 고맙겠지만 그때가 오기 전까지는 API 문서를 잘 써놓고 메서드 이름도 널리 알려진 규약에 따라 짓는 식으로 
 보완이 필요하다. 
 
 > 그럼 그 규약에는 어떤 요소들이 있을지 간단하게 살펴보자
 
 <br>
 
 ### from
 
 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드 라는 의미이다.
 
 ```java
 Date date = Date.from(instance);
 ```
 
 <br>
 
 ### of
 
 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드라는 의미이다.
 
 ```java
 Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);
 ```
 
 <br>
 
 ### valueOf 
 
 `from` 과 `of` 보다 더 자세한 버전이다. 
 
 ```java
 BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);
 ```
 
 <br>
 
 ### instance / getInstance
 
 매개변수를 받는다면 매개변수를 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지 않는다.
 
 ```java
 StackWalker s = StackWalker.getInstance(opt);
 ```
 
 <br>
 <br>
 
 정적 팩토리 메서드와 public 생성자는 각각의 쓰임이 있고 상황에 따라 장단점이 분명하기 때문에 잘 이해하고 쓰는 것이 중요하다. 
 그렇지만, 정적 팩토리를 사용하는게 더 유리한 경우가 많다고 하니, 무작정 public 생성자를 사용하기 보단, 정적 팩토리를 먼저 고려해보는
 습관을 가지고 있는 것이 좋을 듯 하다. 
 
 <br>
 <br>
 <br>
 <br>
