# MySQL 트랜잭션 격리수준(isolation level)에 대한 정리 

<br>

## MySQL 에서 트랜잭션이란?

꼭 여러개의 변경 작업을 수행하는 쿼리에만 적용되는 것이 아니다. 하나의 논리적인 작업에 하나가 있든, 두개가 있든 상관없이
논리적인 작업 셋 자체가 100% 적용되어 커밋이 되거나 그게 아니라면 Rollback 되어 아무것도 적용이 되지 않아야 함을 보장하는 것이다.

<br>

## MySQL의 트랜잭션 격리수준

### READ UNCOMMITTED

각 트랜잭션에서 변경내용이 `commit` 이나 `rollback` 여부에 상관없이 다른 트랜잭션에서 보여지는 레벨이다. 

> 예를들어, 이름이 "jane" 이고 고유번호가 1인 사람을 `INSERT` 할 때, 다른 사용자가 "jane" 내용이 커밋되지도 전에 고유번호 1번에 대해
> 조회하면 "jane"이 보인다. 

<br>

이처럼 어떤 트랜잭션에서 처리한 작업이 채 완료가 되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상을 **더티 리드(Dirty Read)** 라고
하고 이 더티리드가 허용되는 격리수준이 바로 `READ UNCOMMITTED` 이다. 더티리드는 데이터가 나타났다 사라졌다를 반복하기 때문에 상당한
혼란을 만들어왔다고 한다. 그래서 MySQL 에서는 `READ UNCOMMITTED` 이상의 격리 수준을 사용할 것을 권장한다고 한다.

<br>
<br>

### READ COMMITTED

이 격리수준은 오라클 DBMS에서 기본적으로 사용되고 있는 격리수준이다. 특히 온라인 서비스에서 많이 선택되는 격리수준이기도 하다.
`READ UNCOMMITTED` 에서 발생하는 **더티리드(Dirty Read)** 는 발생하지 않는다. 왜냐하면 어떤 트랜잭션에서 데이터를 변경했더라도
`commit` 되지 않았다면 다른 트랜잭션에서는 조회할 수 없기 때문이다. 

> 고유번호가 1번인 "jane" 이 "chloe" 로 변경하는 작업 중일 때, 새로운 값인 "chloe" 는 바로 테이블에 기록되고 "jane" 은 언두 영역(Undo) 
> 으로 백업된다. 만약 "chloe" 로 변경한 사항이 커밋되지 않았다면 다른 사용자가 1번에 대해 조회했을 땐 여전히 "jane" 으로 보여지게 되는데 
> 이때 조회하는 SELECT 쿼리는 "chloe" 가 기록된 테이블을 조회한 것이 아니라 언두 영역에 있는 "jane" 을 조회한 것이다. 

<br>

이 후 변경 사항이 최종 커밋이 되었다면, 비로소 다른 트랜잭션에서 변경된 데이터인 "chloe" 를 읽어올 수 있게 된다. 

<br>

#### 부정합 문제

`READ COMMITTED` 격리 수준에서도 **Non-Repeatable Read** 라는 부정합 문제가 존재한다. 왜 그럴까?

사용자 B는 이름이 "ja%" 인 사용자를 검색했는데 조회되는 건이 없었다. 그런데 사용자 A 가 고유번호 1번인 "jane" 을 "chloe" 로 바꾸는 작업을 진행하고 커밋을 했다.
사용자 B는 똑같은 SELECT 쿼리문을 다시 돌려보았는데 갑자기 1건이 조회가 되는것이다. 이는, **"당연히 문제 없는거 아닌가?"** 라고 생각할 수 있겠지만 하나의 트랜잭션 내에서는
똑같은 SELECT로 조회했을 땐 항상 같은 결과를 가져와야한다는 **Repeatable Read** 의 정합성에 어긋난다.

<br>
<br>

### REPEATABLE READ
 
InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준이다. 바이너리 로그를 가진 MySQL의 장비에서는 `REPEATABLE READ` 격리 수준 이상을 사용해야만 한다. 
이 격리 수준에서는 `READ COMMITTED` 에서 발생하는 `Non-Repeatable Read` 의 부정합이 발생하지 않는다. InnoDB 스토리지 엔진은 트랜잭션이 `Rollback` 될 것을 
대비하여 변경되기 전 레코드를 언두(Undo) 영역에 백업해두고 실제 레코드 값을 변경하는 특징이 있다. (이걸 MVCC 라고 한다)

> 물론 `READ COMMITTED` 도 언두 영역에 백업을 해두지만 `REPEATABLE READ` 와의 차이점은 언두 영역에 백업된 레코드의 여러 버전 중 어느 버전까지 찾아 들어가야 하는지에 있다.

<br>

#### 작동 원리

사용자 A의 트랜잭션 번호는 12, 사용자 B의 트랜잭션 번호는 10 이다. A는 고유번호 1번의 이름 "jane"을 "chloe"로 변경하고 `commit` 을 했다. 그런데 B가 고유번호 1번인 사람의
이름을 A가 변경하기 전과 변경 후에 각각 한번씩 SELECT를 했지만 A가 변경을 수행하고 커밋했음에도 계속 "jane"으로 보였다. B가 트랜잭션을 시작하면서 10번이라는 번호를 부여받았는데
그때부터 사용자 B는 10번 트랜잭션 안에서 실행되는 모든 SELECT 쿼리가 자신의 트랜잭션 번호 10번보다 작은 트랜잭션 번호에서 변경된 것만을 보게 된다.

하나의 레코드에 대해 언두 영역에 백업이 무한대로 얼마든지 존재할 수 있기 때문에 장시간 트랜잭션을 종료하지 않는다면 언두 영역에 데이터가 계속 쌓여 MySQL의 성능이 느려질 수 있으니
주의하도록 하자.

<br>

#### 부정합 문제

`REPEATABLE READ` 에서도 부정합이 발생할 수 있다. 만약 사용자 A가 어떤 데이터를 INSERT 중일 때 사용자 B가 `SELECT .... FOR UPDATE` 쿼리로 테이블을 조회할 때
어떻게 읽어오게 될까?

> 사용자 B 는 트랜잭션 시작 후, SELECT 쿼리를 통해 데이터를 읽어온다. 이 격리수준에서는 두 번의 SELECT 동안에도 결과는 늘 같아야 한다. 그런데 사용자 B는 서로 다른 
> 결과를 얻게 되었다. 이렇게 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안보였다 하는 문제를 **Phantom Read** 라고 한다. 

<br>

`SELECT .. FOR UPDATE` 쿼리는 SELECT 할 때 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수가 없다. 즉, `SELECT .. FOR UPDATE` 나
`SELECT .. LOCK IN SHARE MODE` 에서 조회되는 레코드는 언두 영역의 변경 전 데이터가 아닌, 현재 레코드의 값을 가져오게 될 수 밖에 없는 것이다. 

<br>

#### 그런데!

하지만, `REPEATABLE READ` 를 기본 격리수준으로 사용하는 innoDB 스토리지 엔진에서는 **Phantom Read** 가 발생하지 않는다. 왜 그럴 수 있을까?

innoDB에서 `REPEATABLE READ` 격리 수준을 사용할 때 트랜잭션이 처음으로 읽어간 시간을 기록하여 그 이후 SELECT 에서는 해당 시점을 기준으로 **일관된
읽기(Consistent Read)** 를 수행한다. 때문에 다른 트랜잭션에서 도중에 `commit` 을 하더라도 새로이 커밋된 데이터는 보이지 않는 것이다. 

또한, innoDB는 INSERT 시에 **gap lock**을 사용하여 레코드 그 자체 뿐만 아니라 레코드와 인접한 레코드 사이의 간격을 잠가 
레코드와 레코드 사이의 간격에 새로운 레코드가 INSERT 되는 것을 제어한다. 때문에 **Phantom Read** 가 발생하지 않을 뿐만 아니라 **Dirty Read**, 
**Non-Repeatable Read** 등이 발생하지 않는 것이다.

<br>
<br>

### SERIALIZABLE

가장 엄격한 격리 수준이다. 하지만 그만큼 동시에 처리할 수 있는 성능이 가장 낮다. innoDB는 **잠금이 필요없는 일관된 읽기(Consistent Read)** 의 
특징을 지니고 있지만 `SERIALIZABLE` 에서는 읽기 작업에서도 공유잠금(읽기잠금)이 설정되며 동시에 다른 트랜잭션은 그러한 레코드를 변경조차 못하게 된다..
다시말해, 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근이 불가능 하다는 것이다. 

하지만, `SERIALIZABLE` 에서는 **Phantom Read** 같이 위에서 언급한 문제들은 전혀 발생하지 않는다. 하지만 innoDB는 이미 **Phantom Read** 가 
발생하지 않는 `REPEATABLE READ` 를 구현했기에 굳이 이렇게 엄격한 격리 수준을 사용할 필요는 없다.

<br>
<br>
<br>
<br>

